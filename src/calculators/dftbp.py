#!/usr/bin/env python3
"""
Simple DFTB+ band gap calculator using GFN1-xTB

Usage:
    python dftbp.py [structure_file] [--kpts 3 3 3]

Example:
    python dftbp.py cspbi3.cif --kpts 3 3 3
"""

import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import sys
import os
import subprocess
import argparse
import warnings
from pathlib import Path
from ase.io import read, write

def run_dftbp_bandgap(structure_file, kpts=(3, 3, 3), method="GFN1-xTB", temp=300.0, parameter_file=None, workdir=None):
    """
    Compute band gap using DFTB+ with xTB Hamiltonian
    
    Args:
        structure_file: Path to structure file (cif, xyz, etc.)
        kpts: K-point grid tuple (nx, ny, nz)
        method: xTB method ("GFN1-xTB" or "GFN2-xTB")
        temp: Electronic temperature in Kelvin
    """
    
    print("="*70)
    print(f"DFTB+ Band Gap Calculation ({method})")
    print("="*70)
    
    # Read structure
    print(f"\n[1] Loading structure: {structure_file}")
    atoms = read(structure_file)
    print(f"    Formula: {atoms.get_chemical_formula()}")
    print(f"    Atoms: {len(atoms)}")
    print(f"    Cell volume: {atoms.get_volume():.2f} Angstrom^3")
    print(f"    Periodic: {atoms.get_pbc()}")
    
    # Write structure as XYZ
    print(f"\n[2] Writing struc.xyz for DFTB+")
    workdir_path = Path(workdir) if workdir is not None else Path('.')
    workdir_path.mkdir(parents=True, exist_ok=True)
    write(str(workdir_path / 'struc.xyz'), atoms)
    
    # Create HSD input file
    print(f"\n[3] Creating DFTB+ input file (dftb_in.hsd)")
    print(f"    K-points: {kpts[0]}x{kpts[1]}x{kpts[2]}")
    print(f"    Method: {method}")
    print(f"    Temperature: {temp} K")
    
    create_hsd_input(atoms, kpts, method, temp, parameter_file=parameter_file, workdir=workdir_path)
    
    # Run DFTB+
    print(f"\n[4] Running DFTB+...")
    run_dftbp(cwd=workdir_path)
    
    # Parse results
    print(f"\n[5] Parsing results...")
    
    # Parse energy
    energy = parse_energy(str(workdir_path / 'detailed.out'))
    print(f"    Total energy: {energy:.6f} eV")
    
    # Parse band structure
    eigenvalues, occupations = parse_band_out(str(workdir_path / 'band.out'))
    
    if eigenvalues is not None and occupations is not None:
        print(f"    Found {len(eigenvalues)} eigenvalues")
        
        # Calculate band gap
        bandgap, vbm, cbm = calculate_bandgap(eigenvalues, occupations)
        
        # Parse Fermi level
        fermi = parse_fermi(str(workdir_path / 'detailed.out'))
        
        # Print results
        print("\n" + "="*70)
        print("RESULTS")
        print("="*70)
        print(f"Total Energy:                   {energy:.6f} eV")
        print(f"Valence Band Maximum (VBM):     {vbm:.4f} eV")
        print(f"Conduction Band Minimum (CBM):  {cbm:.4f} eV")
        print(f"Band Gap:                       {bandgap:.4f} eV")
        if fermi is not None:
            print(f"Fermi Level:                    {fermi:.4f} eV")
        print("="*70)
        
        # Plot and save (non-critical, so don't fail if plotting fails)
        try:
            plot_dos(eigenvalues, occupations, vbm, cbm, bandgap, fermi, workdir=workdir_path)
        except Exception as e:
            print(f"    WARNING: Failed to generate DOS plot: {e}")
        
        try:
            save_band_data(eigenvalues, occupations, vbm, cbm, bandgap, workdir=workdir_path)
        except Exception as e:
            print(f"    WARNING: Failed to save band data: {e}")
        
        return bandgap, energy
    else:
        print("    ERROR: Could not parse band structure from band.out")
        return None, energy

def create_hsd_input(atoms, kpts, method, temp, parameter_file=None, workdir=None):
    """Create DFTB+ HSD input file using the explicit geometry specification."""
    
    workdir_path = Path(workdir) if workdir is not None else Path('.')
    with open(workdir_path / 'dftb_in.hsd', 'w') as f:
        f.write('# DFTB+ input for band gap calculation\n')
        f.write('# Auto-generated by dftbp.py\n\n')
        
        # --- NEW: EXPLICIT GEOMETRY BLOCK ---
        # This writes all geometry information directly into the input file,
        # which is more robust than including an external file.
        f.write('Geometry = {\n')
        f.write('  Periodic = Yes\n')

        # Get and map atom types
        symbols = sorted(list(set(atoms.get_chemical_symbols())))
        symbol_map = {symbol: i + 1 for i, symbol in enumerate(symbols)}
        
        # Write TypeNames block
        f.write('  TypeNames = { ' + ' '.join([f'"{s}"' for s in symbols]) + ' }\n')
        
        # Write TypesAndCoordinates block
        f.write('  TypesAndCoordinates [Angstrom] = {\n')
        for atom in atoms:
            type_idx = symbol_map[atom.symbol]
            pos = atom.position
            f.write(f'    {type_idx}  {pos[0]:16.10f}  {pos[1]:16.10f}  {pos[2]:16.10f}\n')
        f.write('  }\n')

        # Write LatticeVectors block
        f.write('  LatticeVectors [Angstrom] = {\n')
        for i in range(3):
            cell_vec = atoms.cell[i, :]
            f.write(f'    {cell_vec[0]:16.10f}  {cell_vec[1]:16.10f}  {cell_vec[2]:16.10f}\n')
        f.write('  }\n')
        
        f.write('}\n\n')
        
        # --- The rest of the file remains the same ---
        f.write('Driver = {}\n\n')
        
        f.write('Hamiltonian = xTB {\n')
        # f.write(f'  Method = "{method}"\n')
        if parameter_file is not None:
            f.write(f'  ParameterFile = "{parameter_file}"\n')
        f.write('  Filling = Fermi {\n')
        f.write(f'    Temperature [Kelvin] = {float(temp)}\n')
        f.write('  }\n')
        
        if any(atoms.get_pbc()):
            f.write('  KPointsAndWeights = SupercellFolding {\n')
            f.write(f'    {kpts[0]} 0 0\n')
            f.write(f'    0 {kpts[1]} 0\n')
            f.write(f'    0 0 {kpts[2]}\n')
            f.write('    0.0 0.0 0.0\n')
            f.write('  }\n')
            
        f.write('}\n\n')
        
        f.write('Options {\n')
        f.write('  WriteDetailedOut = Yes\n')
        f.write('}\n\n')
        
        f.write('Analysis {\n')
        f.write('  WriteBandOut = Yes\n')
        f.write('}\n\n')
        
        f.write('ParserOptions {\n')
        f.write('  ParserVersion = 13\n')
        f.write('}\n\n')
        
        f.write('Parallel {\n')
        f.write('  UseOmpThreads = Yes\n')
        f.write('}\n')



def run_dftbp(cwd=None):
    """Run DFTB+ executable"""
    result = subprocess.run(
        ['dftb+'],
        capture_output=True,
        text=True,
        check=False,
        cwd=str(cwd) if cwd is not None else None
    )
    
    if result.returncode != 0:
        print("\nDFTB+ STDOUT:")
        print(result.stdout)
        print("\nDFTB+ STDERR:")
        print(result.stderr)
        raise RuntimeError(f"DFTB+ failed with exit code {result.returncode}")
    
    # Print DFTB+ output if verbose
    if os.environ.get('DFTBP_VERBOSE'):
        print(result.stdout)


def parse_energy(detailed_out):
    """Parse total energy from detailed.out"""
    with open(detailed_out, 'r') as f:
        for line in f:
            if 'Total energy:' in line:
                parts = line.split()
                for i, part in enumerate(parts):
                    if part == 'eV':
                        return float(parts[i-1])
    raise ValueError("Could not parse energy from detailed.out")


def parse_fermi(detailed_out):
    """Parse Fermi level from detailed.out"""
    if not Path(detailed_out).exists():
        return None
    with open(detailed_out, 'r') as f:
        for line in f:
            if 'Fermi level:' in line:
                parts = line.split()
                for i, part in enumerate(parts):
                    if part == 'eV':
                        return float(parts[i-1])
    return None


def parse_band_out(band_out_file):
    """Parse eigenvalues and occupations from band.out"""
    if not Path(band_out_file).exists():
        return None, None
    
    eigenvalues = []
    occupations = []
    
    with open(band_out_file, 'r') as f:
        for line in f:
            if line.startswith('KPT'):
                continue
            parts = line.split()
            if len(parts) >= 3:
                try:
                    energy_ev = float(parts[1])
                    occupation = float(parts[2])
                    eigenvalues.append(energy_ev)
                    occupations.append(occupation)
                except ValueError:
                    continue
    
    if eigenvalues:
        return np.array(eigenvalues), np.array(occupations)
    return None, None


def calculate_bandgap(eigenvalues, occupations, occ_threshold=0.1):
    """Calculate band gap from eigenvalues and occupations"""
    occupied_mask = occupations > occ_threshold
    unoccupied_mask = occupations < occ_threshold
    
    if not np.any(occupied_mask) or not np.any(unoccupied_mask):
        # Gracefully handle cases with no occupied or unoccupied states
        return 0.0, np.nan, np.nan
    
    vbm = np.max(eigenvalues[occupied_mask])
    cbm = np.min(eigenvalues[unoccupied_mask])
    bandgap = cbm - vbm
    
    return max(0.0, bandgap), vbm, cbm

def write_gen_format(atoms, filename="geometry.gen"):
    """
    Writes the ASE Atoms object to the DFTB+ GenFormat.
    
    Args:
        atoms: ASE Atoms object.
        filename: Name of the file to write.
    """
    with open(filename, 'w') as f:
        # Number of atoms and specification type (Cartesian 'C')
        f.write(f"{len(atoms)} C\n")
        
        # Atom types
        symbols = sorted(list(set(atoms.get_chemical_symbols())))
        f.write(" ".join(symbols) + "\n")
        
        # Atom coordinates and types
        symbol_map = {symbol: i + 1 for i, symbol in enumerate(symbols)}
        for i, atom in enumerate(atoms):
            f.write(
                f"{i+1:5d} {symbol_map[atom.symbol]:3d} "
                f"{atom.position[0]:20.10f} {atom.position[1]:20.10f} {atom.position[2]:20.10f}\n"
            )
            
        # Lattice vectors
        for i in range(3):
            f.write(f"{atoms.cell[i, 0]:20.10f} {atoms.cell[i, 1]:20.10f} {atoms.cell[i, 2]:20.10f}\n")

def plot_dos(eigenvalues, occupations, vbm, cbm, bandgap, fermi=None, workdir=None):
    """Plot density of states"""
    # Skip plotting if vbm or cbm are NaN
    if np.isnan(vbm) or np.isnan(cbm):
        return
    
    fig = None
    try:
        fig = plt.figure(figsize=(10, 6))
        
        occupied_mask = occupations > 0.1
        unoccupied_mask = occupations < 0.1
        
        occupied_energies = eigenvalues[occupied_mask]
        unoccupied_energies = eigenvalues[unoccupied_mask]
        
        if len(occupied_energies) == 0 or len(unoccupied_energies) == 0:
            return
        
        e_min = np.min(eigenvalues) - 2.0
        e_max = np.max(eigenvalues) + 2.0
        bins = np.linspace(e_min, e_max, 100)
        
        plt.hist(occupied_energies, bins=bins, alpha=0.7, label='Occupied', 
                color='blue', edgecolor='blue')
        plt.hist(unoccupied_energies, bins=bins, alpha=0.7, label='Unoccupied', 
                color='red', edgecolor='red')
        
        plt.axvline(vbm, color='blue', linestyle='--', linewidth=2, 
                   label=f'VBM = {vbm:.2f} eV')
        plt.axvline(cbm, color='red', linestyle='--', linewidth=2, 
                   label=f'CBM = {cbm:.2f} eV')
        
        if fermi is not None and not np.isnan(fermi):
            plt.axvline(fermi, color='green', linestyle=':', linewidth=2, 
                       label=f'E_F = {fermi:.2f} eV')
        
        plt.axvspan(vbm, cbm, alpha=0.2, color='yellow', 
                   label=f'Gap = {bandgap:.2f} eV')
        
        plt.xlabel('Energy (eV)', fontsize=12)
        plt.ylabel('Density of States', fontsize=12)
        plt.title('DFTB+ Electronic DOS', fontsize=14, fontweight='bold')
        plt.legend(fontsize=10, loc='best')
        plt.grid(True, alpha=0.3)
        
        # Suppress tight_layout warning by catching it, or just use bbox_inches in savefig
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", UserWarning)
            plt.tight_layout()
        
        outdir = Path(workdir) if workdir is not None else Path('.')
        plt.savefig(outdir / 'dos_dftbp.png', dpi=300, bbox_inches='tight')
        print(f"\n    DOS plot saved: {outdir / 'dos_dftbp.png'}")
    finally:
        if fig is not None:
            plt.close(fig)
        elif plt.get_fignums():
            plt.close('all')


def save_band_data(eigenvalues, occupations, vbm, cbm, bandgap, workdir=None):
    """Save band structure data to file"""
    outdir = Path(workdir) if workdir is not None else Path('.')
    with open(outdir / 'band_data_dftbp.txt', 'w') as f:
        f.write("# DFTB+ Band Structure Data\n")
        f.write(f"# VBM = {vbm:.6f} eV\n")
        f.write(f"# CBM = {cbm:.6f} eV\n")
        f.write(f"# Band Gap = {bandgap:.6f} eV\n")
        f.write("#\n")
        f.write("# Index    Energy(eV)    Occupation\n")
        for i, (e, occ) in enumerate(zip(eigenvalues, occupations)):
            f.write(f"{i+1:6d}    {e:12.6f}    {occ:8.4f}\n")
    print(f"    Band data saved: {outdir / 'band_data_dftbp.txt'}")


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='Compute band gap using DFTB+ with GFN1-xTB',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python dftbp.py cspbi3.cif
  pixi run python dftbp.py cspbi3.cif --kpts 3 3 3
  python dftbp.py cspbi3.cif --kpts 6 6 6 --temp 500
  python dftbp.py relaxed_structure.xyz --method GFN2-xTB
        """
    )
    
    parser.add_argument('structure', 
                       help='Structure file (cif, xyz, POSCAR, etc.)')
    parser.add_argument('--kpts', nargs=3, type=int, default=[3, 3, 3],
                       help='K-point grid (default: 3 3 3)')
    parser.add_argument('--method', default='GFN1-xTB',
                       choices=['GFN1-xTB', 'GFN2-xTB'],
                       help='xTB method (default: GFN1-xTB for band gaps)')
    parser.add_argument('--temp', type=float, default=300.0,
                       help='Electronic temperature in K (default: 300)')
    
    args = parser.parse_args()
    
    
    
    # Check if structure file exists
    if not Path(args.structure).exists():
        print(f"ERROR: Structure file not found: {args.structure}")
        sys.exit(1)
    
    # Run calculation
    kpts = tuple(args.kpts)
    bandgap, _energy = run_dftbp_bandgap(args.structure, kpts, args.method, args.temp, parameter_file=None, workdir=None)
    
    if bandgap is not None:
        print(f"\nSUCCESS: Band gap = {bandgap:.4f} eV")
        return 0
    else:
        print("\nERROR: Band gap calculation failed")
        return 1


if __name__ == "__main__":
    sys.exit(main())
