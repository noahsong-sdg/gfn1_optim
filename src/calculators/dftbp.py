#!/usr/bin/env python3
"""
Simple DFTB+ band gap calculator using GFN1-xTB

Usage:
    python dftbp.py [structure_file] [--kpts 3 3 3]

Example:
    python dftbp.py cspbi3.cif --kpts 3 3 3
"""

import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import sys
import os
import subprocess
import argparse
from pathlib import Path
from ase.io import read, write

def run_dftbp_bandgap(structure_file, kpts=(3, 3, 3), method="GFN1-xTB", temp=300.0, parameter_file=None, workdir=None):
    """
    Compute band gap using DFTB+ with xTB Hamiltonian
    
    Args:
        structure_file: Path to structure file (cif, xyz, etc.)
        kpts: K-point grid tuple (nx, ny, nz)
        method: xTB method ("GFN1-xTB" or "GFN2-xTB")
        temp: Electronic temperature in Kelvin
    """
    
    print("="*70)
    print(f"DFTB+ Band Gap Calculation ({method})")
    print("="*70)
    
    # Read structure
    print(f"\n[1] Loading structure: {structure_file}")
    atoms = read(structure_file)
    print(f"    Formula: {atoms.get_chemical_formula()}")
    print(f"    Atoms: {len(atoms)}")
    print(f"    Cell volume: {atoms.get_volume():.2f} Angstrom^3")
    print(f"    Periodic: {atoms.get_pbc()}")
    
    # Write structure as XYZ
    print(f"\n[2] Writing struc.xyz for DFTB+")
    workdir_path = Path(workdir) if workdir is not None else Path('.')
    workdir_path.mkdir(parents=True, exist_ok=True)
    write(str(workdir_path / 'struc.xyz'), atoms)
    
    # Create HSD input file
    print(f"\n[3] Creating DFTB+ input file (dftb_in.hsd)")
    print(f"    K-points: {kpts[0]}x{kpts[1]}x{kpts[2]}")
    print(f"    Method: {method}")
    print(f"    Temperature: {temp} K")
    
    create_hsd_input(atoms, kpts, method, temp, parameter_file=parameter_file, workdir=workdir_path)
    
    # Run DFTB+
    print(f"\n[4] Running DFTB+...")
    run_dftbp(cwd=workdir_path)
    
    # Parse results
    print(f"\n[5] Parsing results...")
    
    # Parse energy
    energy = parse_energy(str(workdir_path / 'detailed.out'))
    print(f"    Total energy: {energy:.6f} eV")
    
    # Parse band structure
    eigenvalues, occupations = parse_band_out(str(workdir_path / 'band.out'))
    
    if eigenvalues is not None and occupations is not None:
        print(f"    Found {len(eigenvalues)} eigenvalues")
        
        # Calculate band gap
        bandgap, vbm, cbm = calculate_bandgap(eigenvalues, occupations)
        
        # Parse Fermi level
        fermi = parse_fermi('detailed.out')
        
        # Print results
        print("\n" + "="*70)
        print("RESULTS")
        print("="*70)
        print(f"Total Energy:                   {energy:.6f} eV")
        print(f"Valence Band Maximum (VBM):     {vbm:.4f} eV")
        print(f"Conduction Band Minimum (CBM):  {cbm:.4f} eV")
        print(f"Band Gap:                       {bandgap:.4f} eV")
        if fermi is not None:
            print(f"Fermi Level:                    {fermi:.4f} eV")
        print("="*70)
        
        # Plot and save
        plot_dos(eigenvalues, occupations, vbm, cbm, bandgap, fermi, workdir=workdir_path)
        save_band_data(eigenvalues, occupations, vbm, cbm, bandgap, workdir=workdir_path)
        
        return bandgap, energy
    else:
        print("    ERROR: Could not parse band structure from band.out")
        return None, energy

def create_hsd_input(atoms, kpts, method, temp, parameter_file=None, workdir=None):
    """Create DFTB+ HSD input file using the explicit geometry specification."""
    
    workdir_path = Path(workdir) if workdir is not None else Path('.')
    with open(workdir_path / 'dftb_in.hsd', 'w') as f:
        f.write('# DFTB+ input for band gap calculation\n')
        f.write('# Auto-generated by dftbp.py\n\n')
        
        # --- NEW: EXPLICIT GEOMETRY BLOCK ---
        # This writes all geometry information directly into the input file,
        # which is more robust than including an external file.
        f.write('Geometry = {\n')
        f.write('  Periodic = Yes\n')

        # Get and map atom types
        symbols = sorted(list(set(atoms.get_chemical_symbols())))
        symbol_map = {symbol: i + 1 for i, symbol in enumerate(symbols)}
        
        # Write TypeNames block
        f.write('  TypeNames = { ' + ' '.join([f'"{s}"' for s in symbols]) + ' }\n')
        
        # Write TypesAndCoordinates block
        f.write('  TypesAndCoordinates [Angstrom] = {\n')
        for atom in atoms:
            type_idx = symbol_map[atom.symbol]
            pos = atom.position
            f.write(f'    {type_idx}  {pos[0]:16.10f}  {pos[1]:16.10f}  {pos[2]:16.10f}\n')
        f.write('  }\n')

        # Write LatticeVectors block
        f.write('  LatticeVectors [Angstrom] = {\n')
        for i in range(3):
            cell_vec = atoms.cell[i, :]
            f.write(f'    {cell_vec[0]:16.10f}  {cell_vec[1]:16.10f}  {cell_vec[2]:16.10f}\n')
        f.write('  }\n')
        
        f.write('}\n\n')
        
        # --- The rest of the file remains the same ---
        f.write('Driver = {}\n\n')
        
        f.write('Hamiltonian = xTB {\n')
        # f.write(f'  Method = "{method}"\n')
        if parameter_file is not None:
            f.write(f'  ParameterFile = "{parameter_file}"\n')
        f.write('  Filling = Fermi {\n')
        f.write(f'    Temperature [Kelvin] = {float(temp)}\n')
        f.write('  }\n')
        
        if any(atoms.get_pbc()):
            f.write('  KPointsAndWeights = SupercellFolding {\n')
            f.write(f'    {kpts[0]} 0 0\n')
            f.write(f'    0 {kpts[1]} 0\n')
            f.write(f'    0 0 {kpts[2]}\n')
            f.write('    0.5 0.5 0.5\n')
            f.write('  }\n')
            
        f.write('}\n\n')
        
        f.write('Options {\n')
        f.write('  WriteDetailedOut = Yes\n')
        # f.write('  WriteBandOut = Yes\n')
        f.write('}\n\n')

        f.write('ParserOptions {\n')
        f.write('  ParserVersion = 13\n')
        f.write('}\n\n')
        
        f.write('Parallel {\n')
        f.write('  UseOmpThreads = Yes\n')
        f.write('}\n')



def run_dftbp(cwd=None):
    """Run DFTB+ executable"""
    result = subprocess.run(
        ['dftb+'],
        capture_output=True,
        text=True,
        check=False,
        cwd=str(cwd) if cwd is not None else None
    )
    
    if result.returncode != 0:
        print("\nDFTB+ STDOUT:")
        print(result.stdout)
        print("\nDFTB+ STDERR:")
        print(result.stderr)
        raise RuntimeError(f"DFTB+ failed with exit code {result.returncode}")
    
    # Print DFTB+ output if verbose
    if os.environ.get('DFTBP_VERBOSE'):
        print(result.stdout)


def parse_energy(detailed_out):
    """Parse total energy from detailed.out"""
    with open(detailed_out, 'r') as f:
        for line in f:
            if 'Total energy:' in line:
                parts = line.split()
                for i, part in enumerate(parts):
                    if part == 'eV':
                        return float(parts[i-1])
    raise ValueError("Could not parse energy from detailed.out")


def parse_fermi(detailed_out):
    """Parse Fermi level from detailed.out"""
    if not Path(detailed_out).exists():
        return None
    with open(detailed_out, 'r') as f:
        for line in f:
            if 'Fermi level:' in line:
                parts = line.split()
                for i, part in enumerate(parts):
                    if part == 'eV':
                        return float(parts[i-1])
    return None


def parse_band_out(band_out_file):
    """Parse eigenvalues and occupations from band.out"""
    if not Path(band_out_file).exists():
        return None, None
    
    eigenvalues = []
    occupations = []
    
    with open(band_out_file, 'r') as f:
        for line in f:
            if line.startswith('KPT'):
                continue
            parts = line.split()
            if len(parts) >= 3:
                try:
                    energy_ev = float(parts[1])
                    occupation = float(parts[2])
                    eigenvalues.append(energy_ev)
                    occupations.append(occupation)
                except ValueError:
                    continue
    
    if eigenvalues:
        return np.array(eigenvalues), np.array(occupations)
    return None, None


def calculate_bandgap(eigenvalues, occupations, occ_threshold=0.1):
    """Calculate band gap from eigenvalues and occupations"""
    occupied_mask = occupations > occ_threshold
    unoccupied_mask = occupations < occ_threshold
    
    if not np.any(occupied_mask) or not np.any(unoccupied_mask):
        # Gracefully handle cases with no occupied or unoccupied states
        return 0.0, np.nan, np.nan
    
    vbm = np.max(eigenvalues[occupied_mask])
    cbm = np.min(eigenvalues[unoccupied_mask])
    bandgap = cbm - vbm
    
    return max(0.0, bandgap), vbm, cbm

def write_gen_format(atoms, filename="geometry.gen"):
    """
    Writes the ASE Atoms object to the DFTB+ GenFormat.
    
    Args:
        atoms: ASE Atoms object.
        filename: Name of the file to write.
    """
    with open(filename, 'w') as f:
        # Number of atoms and specification type (Cartesian 'C')
        f.write(f"{len(atoms)} C\n")
        
        # Atom types
        symbols = sorted(list(set(atoms.get_chemical_symbols())))
        f.write(" ".join(symbols) + "\n")
        
        # Atom coordinates and types
        symbol_map = {symbol: i + 1 for i, symbol in enumerate(symbols)}
        for i, atom in enumerate(atoms):
            f.write(
                f"{i+1:5d} {symbol_map[atom.symbol]:3d} "
                f"{atom.position[0]:20.10f} {atom.position[1]:20.10f} {atom.position[2]:20.10f}\n"
            )
            
        # Lattice vectors
        for i in range(3):
            f.write(f"{atoms.cell[i, 0]:20.10f} {atoms.cell[i, 1]:20.10f} {atoms.cell[i, 2]:20.10f}\n")

def plot_dos(eigenvalues, occupations, vbm, cbm, bandgap, fermi=None, workdir=None):
    """Plot density of states"""
    plt.figure(figsize=(10, 6))
    
    occupied_mask = occupations > 0.1
    unoccupied_mask = occupations < 0.1
    
    occupied_energies = eigenvalues[occupied_mask]
    unoccupied_energies = eigenvalues[unoccupied_mask]
    
    e_min = np.min(eigenvalues) - 2.0
    e_max = np.max(eigenvalues) + 2.0
    bins = np.linspace(e_min, e_max, 100)
    
    plt.hist(occupied_energies, bins=bins, alpha=0.7, label='Occupied', 
            color='blue', edgecolor='blue')
    plt.hist(unoccupied_energies, bins=bins, alpha=0.7, label='Unoccupied', 
            color='red', edgecolor='red')
    
    plt.axvline(vbm, color='blue', linestyle='--', linewidth=2, 
               label=f'VBM = {vbm:.2f} eV')
    plt.axvline(cbm, color='red', linestyle='--', linewidth=2, 
               label=f'CBM = {cbm:.2f} eV')
    
    if fermi is not None:
        plt.axvline(fermi, color='green', linestyle=':', linewidth=2, 
                   label=f'E_F = {fermi:.2f} eV')
    
    plt.axvspan(vbm, cbm, alpha=0.2, color='yellow', 
               label=f'Gap = {bandgap:.2f} eV')
    
    plt.xlabel('Energy (eV)', fontsize=12)
    plt.ylabel('Density of States', fontsize=12)
    plt.title('DFTB+ Electronic DOS', fontsize=14, fontweight='bold')
    plt.legend(fontsize=10, loc='best')
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    
    outdir = Path(workdir) if workdir is not None else Path('.')
    plt.savefig(outdir / 'dos_dftbp.png', dpi=300, bbox_inches='tight')
    print(f"\n    DOS plot saved: {outdir / 'dos_dftbp.png'}")
    plt.close()


def save_band_data(eigenvalues, occupations, vbm, cbm, bandgap, workdir=None):
    """Save band structure data to file"""
    outdir = Path(workdir) if workdir is not None else Path('.')
    with open(outdir / 'band_data_dftbp.txt', 'w') as f:
        f.write("# DFTB+ Band Structure Data\n")
        f.write(f"# VBM = {vbm:.6f} eV\n")
        f.write(f"# CBM = {cbm:.6f} eV\n")
        f.write(f"# Band Gap = {bandgap:.6f} eV\n")
        f.write("#\n")
        f.write("# Index    Energy(eV)    Occupation\n")
        for i, (e, occ) in enumerate(zip(eigenvalues, occupations)):
            f.write(f"{i+1:6d}    {e:12.6f}    {occ:8.4f}\n")
    print(f"    Band data saved: {outdir / 'band_data_dftbp.txt'}")


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='Compute band gap using DFTB+ with GFN1-xTB',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python dftbp.py cspbi3.cif
  pixi run python dftbp.py cspbi3.cif --kpts 3 3 3
  python dftbp.py cspbi3.cif --kpts 6 6 6 --temp 500
  python dftbp.py relaxed_structure.xyz --method GFN2-xTB
        """
    )
    
    parser.add_argument('structure', 
                       help='Structure file (cif, xyz, POSCAR, etc.)')
    parser.add_argument('--kpts', nargs=3, type=int, default=[3, 3, 3],
                       help='K-point grid (default: 3 3 3)')
    parser.add_argument('--method', default='GFN1-xTB',
                       choices=['GFN1-xTB', 'GFN2-xTB'],
                       help='xTB method (default: GFN1-xTB for band gaps)')
    parser.add_argument('--temp', type=float, default=300.0,
                       help='Electronic temperature in K (default: 300)')
    
    args = parser.parse_args()
    
    
    
    # Check if structure file exists
    if not Path(args.structure).exists():
        print(f"ERROR: Structure file not found: {args.structure}")
        sys.exit(1)
    
    # Run calculation
    kpts = tuple(args.kpts)
    bandgap, _energy = run_dftbp_bandgap(args.structure, kpts, args.method, args.temp, parameter_file=None, workdir=None)
    
    if bandgap is not None:
        print(f"\nSUCCESS: Band gap = {bandgap:.4f} eV")
        return 0
    else:
        print("\nERROR: Band gap calculation failed")
        return 1


if __name__ == "__main__":
    sys.exit(main())
